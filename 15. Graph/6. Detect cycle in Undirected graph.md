# Detect cycle in Undirected graph

In an **undirected graph**, a cycle is detected if we revisit a node that isn’t the direct parent of the current node (i.e., we find a back edge).

# 1. DFS Based Approach

## Key Idea

- DFS naturally explores all possible paths from a given starting node. If DFS encounters an already visited node that isn’t its immediate parent, this indicates a back edge, meaning there’s a cycle in the graph.

## Step by Step Algorithm

**Step 1**: Initialize the Visited Array

- We create a visited array of boolean values, to track whether a vertex has already been visited.

**Step 2**: Loop through Each Vertex

- We initiate the DFS traversal from each vertex that hasn't been visited yet. This helps ensure that every connected component is checked for cycles.

**Step 3**: DFS Traversal with Cycle Check

- The DFS traversal is managed by the helper function `detectCycleRecursive`, which accepts the current vertex (`u`), the adjacency list (`adj`), the parent vertex (`parentVertex`), and the `visited` array.
- **Mark the Node as Visited**: Set `visited[u] = true` to mark the current node as visited.

**Step 4**: Explore Each Neighbor

- For each adjacent vertex `v` of `u`:
  - **Check if `v` is Unvisited**:
    - If `v` hasn’t been visited, make a recursive DFS call with `v` as the new node and `u` as its parent.
    - If any recursive call returns `true`, a cycle has been detected, and the function immediately returns `true` up the recursive chain.
  - **Check if `v` is Visited and Not the Parent**:
    - If `v` is already visited and isn’t `u`'s parent, it means we’ve encountered a back edge (i.e., a cycle).
    - Return `true` immediately if this condition is met.

**Step 5**: Return False if No Cycle Found

- If none of the paths lead to a cycle, return `false`, indicating that this component doesn’t contain a cycle.

**Step 6**: Cycle Detection in All Components

- Repeat this process for every unvisited vertex in the graph to check for cycles across all connected components.
- If any component returns `true`, there’s a cycle in the graph.

## Implementation

```java
// Helper function for DFS-based cycle detection
public static boolean detectCycleRecursive(ArrayList<ArrayList<Integer>> adj, int u, int parentVertex, boolean[] visited) {
    visited[u] = true;  // Mark the current node as visited

    for (int v : adj.get(u)) {  // Traverse all adjacent vertices of u
        if (!visited[v]) {
            // If adjacent vertex `v` is not visited, recur with `v` as the current node
            if (detectCycleRecursive(adj, v, u, visited)) {
                return true;  // If a cycle is detected in recursion, return true
            }
        } else if (v != parentVertex) {
            // If adjacent vertex `v` is visited and isn't the parent, we found a back edge (cycle)
            return true;
        }
    }
    return false;  // No cycle found in this path
}

// Main function to detect cycle in an undirected graph
public static boolean detectCycle(ArrayList<ArrayList<Integer>> adj, int vertices) {
    boolean[] visited = new boolean[vertices];  // Initialize visited array

    for (int i = 0; i < vertices; i++) {  // Check each component of the graph
        if (!visited[i]) {  // If vertex `i` is unvisited, check this component
            if (detectCycleRecursive(adj, i, -1, visited)) {
                return true;  // If any component has a cycle, return true
            }
        }
    }
    return false;  // No cycles found in any component
}
```

# 2. BFS Based Approach

## Key Idea

- The basic idea will be same as DFS, a cycle is detected when a vertex is visited that is not an immediate parent.
- We create a structure to store the current vertex and the immediate parent.
- Then apply standard BFS algorithm, adding new entry to queue with new vertex and its parent and marking the new vertex as visited.

## Step by Step Algorithm

**Step 1**: Initialize the Visited Array and Queue

- We create a visited array of boolean values, to track whether a vertex has already been visited.
- Create a queue for BFS traversal.

**Step 2**: For each unvisited vertex we do the following:

- We mark it as visited.
- Create an object with the current vertex and its parent (-1 for first vertex) and store it in queue.
- Do following while queue is not empty:
  - Pop object from queue and obtain current vertex (`u`) and its parent.
  - For each adjecent vertices (`v`):
    - If its not visited:
      - Add an object to queue with the adject vertex and parent as current vertex.
      - Mark it as visited.
    - If its already visited:
      - Check if it is the parent of current element:
        - If not, return `true` as we got a node already visited that is not immediate parent of current node.
- Return `false` as no cycle was found during the BFS traversal for current start vertex.

**Step 3**: Return `false` as no cycle was detected in entire graph.

```java
class Pair {
    int vertex;
    int parent;

    public Pair(int vertex, int parent) {
        this.vertex = vertex;
        this.parent = parent;
    }
}

public boolean detectCycleInComponent(int start, ArrayList<ArrayList<Integer>> adj, boolean[] visited) {
    Queue<Pair> queue = new ArrayDeque<>();
    queue.offer(new Pair(start, -1));
    visited[start] = true;

    while(!queue.isEmpty()) {
        Pair current = queue.poll();
        int u = current.vertex;
        int parent = current.parent;

        for(int v: adj.get(u)) {
            if(!visited[v]) {
                queue.offer(new Pair(v, u));
                visited[v] = true;
            }else {
                if(v != parent) return true;
            }
        }
    }

    return false;
}

public boolean isCycle(int V, ArrayList<ArrayList<Integer>> adj) {
    // STEP 1: Create visited array
    boolean[] visited = new boolean[V];

    // STEP 2: Check cycle for every unvisted vertex, handles the case when graph is disconected
    for(int i=0; i<V; i++) {
        if(!visited[i]) {
            if(detectCycleInComponent(i, adj, visited)) return true;
        }
    }

    // STEP 3: Return false as no cycle was detected in entire graph
    return false;

}
```
