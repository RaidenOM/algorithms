# Topological Sorting

Topological sorting is an ordering of vertices in a Directed Acyclic Graph (DAG) such that for every directed edge `u â†’ v` which implies vertex `v` has dependency on `u` where `u` is a job, vertex `u` is processed first in the ordering.

This type of ordering is useful in scenarios like task scheduling, where some tasks must be completed before others.

# 1. BFS Based approach

## Step by Step Algorithm

**Step 1**: Calculate In-degrees

- For each vertex in the graph, calculate the in-degree, which is the number of edges directed into the vertex.
- This in-degree array will help identify vertices with no dependencies (in-degree of 0) to process them first.

**Step 2**: Initialize the Queue

- Initialize an empty queue and enqueue all vertices with an in-degree of 0. These are vertices that have no dependencies and can be processed immediately.

**Step 3**: Process Vertices in the Queue

- While the queue is not empty:
  - Dequeue a vertex `u` from the queue and add process it (this vertex has no remaining dependencies).
  - For each adjacent vertex `x` of `u`:
    - Decrease the in-degree of `x` by 1 because `u` has now been processed.
    - If `x` in-degree becomes 0, enqueue `x` (as it now has no dependencies left).

**Step 4**: Repeat Until All Vertices Are Processed

- Continue processing vertices from the queue until the queue is empty. Each dequeued vertex is part of the topological ordering.

## Implementation

```java
public static void topologicalSortingBFS(ArrayList<ArrayList<Integer>> adj, int vertices) {
    Queue<Integer> queue = new LinkedList<>();
    int[] indegree = new int[vertices];

    // Calculating indegree
    for (int i = 0; i < vertices; i++) {
        for (int x : adj.get(i)) {
            indegree[x]++;
        }
    }

    // Adding all nodes to queue whose indegree is 0
    for (int i = 0; i < vertices; i++) {
        if (indegree[i] == 0) {
            queue.offer(i);
        }
    }

    while (!queue.isEmpty()) {
        // Enqueue a node and print it
        int u = queue.poll();
        System.out.println(u);

        // Explore its adjecents and decrement their indegree by 1
        // If indegree of any adjecent becomes 0, enqueue it
        for (int x : adj.get(u)) {
            indegree[x]--;
            if (indegree[x] == 0) {
                queue.offer(x);
            }
        }
    }
}
```

# 2. DFS Based approach
