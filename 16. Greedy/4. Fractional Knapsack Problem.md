# Fractional Knapsack Problem

## Problem Statement

- Given two arrays, **val[]** and **wt[]**, representing the values and weights of items, and an integer **capacity** representing the maximum weight a knapsack can hold.
- Determine the maximum total value that can be achieved by putting items in the knapsack. You are allowed to break items into fractions if necessary.

## Key Idea

- The basic idea of the greedy approach is to calculate the ratio **profit/weight** for each item and sort the item on the basis of this ratio.
- Then take the item with the highest ratio and add them as much as we can (can be the whole element or a fraction of it).
- This will always give the maximum profit because, in each step it adds an element such that this is the maximum possible profit for that much weight.

## Step by Step Algorithm

**Step 1**: Create an `Item` Structure with `weight` and `value`.

**Step 2**: Implement a `compareTo` function to sort items in descending order of `value/weight`.

**Step 3**: Initialize profit and start picking items

- Start with `profit = 0`.
- Iterate over sorted items:
  - If the **current item’s weight ≤ remaining capacity (W)**:
    - Take the whole item.
    - Increase profit by item’s value.
    - Decrease `W` by item’s weight.
  - Else (item is too heavy to fit entirely):
    - Take a fraction of it.
    - Add to profit: `(W / currentWeight) * currentValue`.
    - Set `W` to 0 (knapsack is full) and stop.

**Step 4**: Return the total profit.

## Implementation

```java
class Item implements Comparable<Item> {
    int value;
    int weight;

    public Item(int value, int weight) {
        this.value = value;
        this.weight = weight;
    }

    @Override
    public int compareTo(Item item) {
        double currentRatio = (double) value / weight;
        double nextRatio = (double) item.value / item.weight;

        return Double.compare(nextRatio, currentRatio);
    }
}

class Solution {
    double fractionalKnapsack(int[] values, int[] weights, int W) {
        int size = values.length;
        Item[] items = new Item[size];

        for(int i=0; i<size; i++) {
            items[i] = new Item(values[i], weights[i]);
        }

        Arrays.sort(items);

        double profit = 0;
        for(int i=0; i<size; i++) {
            int currentWeight = items[i].weight;
            int currentProfit = items[i].value;

            if(W >= currentWeight) {
                W -= currentWeight;
                profit += currentProfit;
            }else {
                profit += ((double) W / currentWeight) * currentProfit;
                W = 0;
                break; // knapsack is full
            }
        }

        return profit;
    }
}
```
