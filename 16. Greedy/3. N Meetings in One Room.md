# N Meetings in One Room

## Problem Statement

You are given two arrays `start[]` and `end[]` of the same length `n`. Each pair (`start[i]`, `end[i]`) is a meeting scheduled in one room. Pick the maximum number of meetings that can be held in that single room without overlapping. Return that maximum count.

**Note**: The start time of one chosen meeting can't be equal to the end time of the other chosen meeting.

## Key Idea

To maximize the number of non-overlapping meetings you should **always pick the meeting that finishes earliest** (among the remaining meetings).
Why? Because a meeting that finishes earlier leaves the most remaining time to schedule other meetings. This is the classic "activity selection" greedy strategy.

1. Pair up starts and ends into intervals.
2. Sort intervals by their end time (ascending).
3. Iterate over the sorted list and greedily select an interval if it does not overlap with the last selected one.

## Step by Step Algorithm

**Step 1**: Represent meetings clearly

- Pair up each meeting's start and end time into a single `Interval` object.

**Step 2**: Sort the meetings by end time

- Sort all meetings in ascending order of their end time.
- Because a meeting that finishes earlier leaves the most remaining time to schedule other meetings.

**Step 3**: Initialize selection

- Pick the first meeting in the sorted list — it will always be part of the optimal solution because it ends earliest.
- Set a variable `freeTime` to this meeting’s end time — meaning you’re next available after this time.
- Set `count = 1` because we’ve already chosen one meeting.

**Step 4**: Iterate through remaining meetings

- For each subsequent meeting in the sorted list:
  - If the start time of the meeting is strictly greater than `freeTime` (meaning it starts after the last chosen meeting ends),
    - Select this meeting
    - Increase `count` by 1
    - Update `freeTime` to the end time of this newly selected meeting
  - Otherwise, skip the meeting (it overlaps with the one you’re currently attending).

**Step 5**: Return the count

- After checking all meetings, the `count` variable holds the maximum number of meetings you can attend.

## Implementation

```java
class Interval implements Comparable<Interval> {
    int start;
    int end;

    public Interval(int start, int end) {
        this.start = start;
        this.end = end;
    }

    @Override
    public int compareTo(Interval interval) {
        return this.end - interval.end;
    }
}

class Solution {

    public int maxMeetings(int start[], int end[]) {
        int size = start.length;

        Interval[] intervals = new Interval[size];

        for(int i=0; i<size; i++) {
            intervals[i] = new Interval(start[i], end[i]);
        }

        Arrays.sort(intervals);

        int count = 1;
        int freeTime = intervals[0].end;

        for(int i=1; i<size; i++) {
            if(intervals[i].start > freeTime) {
                count++;
                freeTime = intervals[i].end;
            }
        }

        return count;
    }
}
```
