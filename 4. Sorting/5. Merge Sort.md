# Merge Sort

## Key Idea

**Merge Sort** is a **divide-and-conquer** sorting algorithm. The main idea is to:

- **Divide** the array into two halves based on indices.
- **Recursively sort** each half.
- **Merge** the two sorted halves into a single sorted array.

The key strength of Merge Sort lies in the merge step, where two sorted subarrays are combined into one sorted array in linear time.

## Step by Step Algorithm

**Step 1**: Start the Sort

- Begin with the full array.

- Consider two pointers: a start index and an end index that define the current section of the array you are working with.

**Step 2**: Divide the Array

- If the current section has more than one element, divide it into two halves:

- Find the middle point between the start and end.

- This gives you two halves: left half and right half.

**Step 3**: Sort Each Half

- Recursively apply the same divide process to both the left and right halves.

- Keep dividing until each section has only one element.

- At this point, all sections are trivially sorted because a single item is always sorted.

**Step 4**: Merge Two Sorted Halves
Now, begin combining the sorted halves back together. This happens in three key sub-steps:

- Prepare to Merge

  - Create two temporary arrays — one for each sorted half.
  - These hold the elements you’re about to merge.

- Merge with Comparisons

  - Use three pointers:
    - **Pointer A**: Traverses the first (`left`) temporary array.
    - **Pointer B**: Traverses the second (`right`) temporary array.
    - **Pointer C**: Tracks the current position in the original array (starting from the `low` index).
  - Repeat the following:
    - Compare the elements pointed to by A and B.
    - Copy the smaller of the two into the position indicated by C in the original array.
    - Move Pointer C forward by one.
    - Also move the pointer (A or B) that pointed to the smaller element.
    - Continue this process until one of the two temporary arrays is fully traversed.

- Add Remaining Items
  If one array still has items left after the comparisons, copy all remaining items from that array into the main array.

## Implementation

```java
void merge(int[] arr, int low, int mid, int high) {
    int n = mid - low + 1;
    int m = high - mid;

    int[] left = new int[n];
    int[] right = new int[m];

    for(int i=0; i<n; i++) {
        left[i] = arr[low + i];
    }

    for(int i=0; i<m; i++) {
        right[i] = arr[mid + 1 + i];
    }

    int i = 0;
    int j = 0;
    int k = low;

    while(i < n && j < m) {
        if(left[i] <= right[j]) {
            arr[k++] = left[i++];
        }else {
            arr[k++] = right[j++];
        }
    }

    while(i < n) {
        arr[k++] = left[i++];
    }

    while(j < m) {
        arr[k++] = right[j++];
    }
}

void mergeSort(int arr[], int low, int high) {
    if(low >= high) return;
    int mid = (low + high) / 2;
    mergeSort(arr, low, mid);
    mergeSort(arr, mid + 1, high);
    merge(arr, low, mid, high);
}
```
